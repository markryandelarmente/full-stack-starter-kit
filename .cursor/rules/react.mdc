---
description: React development patterns and best practices
globs: apps/web/**/*.{ts,tsx}
---

# React Development Rules

## Component Structure

- Use functional components with TypeScript
- Place component files in `src/components/` or feature-specific folders
- Co-locate related files (component, styles, tests, types)
- Use named exports for components

```tsx
// Good: Named export with TypeScript
export function UserCard({ user }: UserCardProps) {
  return <div>{user.name}</div>;
}

// Avoid: Default exports
export default function UserCard() {}
```

## Component Organization

```
src/
├── components/        # Reusable components (app-specific)
│   └── [feature]/    # Feature-specific components
├── routes/           # TanStack Router file-based routes
│   ├── __root.tsx    # Root route with context
│   ├── index.tsx     # Home page (/)
│   ├── (app)/        # Pathless layout group
│   │   ├── route.tsx # Layout component
│   │   └── dashboard.tsx
│   └── (auth)/       # Pathless layout group
│       ├── route.tsx # Auth layout
│       └── sign-in.tsx
├── hooks/            # API and TanStack Query hooks
│   └── api/          # API-domain hooks (feature-based)
│       ├── users/
│       │   ├── users-keys.ts    # Query key factory
│       │   ├── users-queries.ts # Query hooks & fetch functions
│       │   └── users-mutation.ts
│       └── files/
│           ├── files-keys.ts
│           ├── files-queries.ts
│           └── files-mutation.ts
├── lib/              # Utilities and helpers (app-specific)
└── types/            # TypeScript types
```

**Note:** All reusable UI components (Shadcn) are located in the `@repo/ui` package at `packages/ui/src/components/`. See the "UI Components" section below.

## State Management

- Use TanStack Query (`@tanstack/react-query`) for server state
- Use `useState` and `useReducer` for local UI state
- TanStack Query cache acts as global server state - no need for Redux/Zustand for API data
- Lift state only when necessary

```tsx
// Server state: Use query hooks from @/hooks/api/[domain]
const { data: user, isLoading } = useCurrentUser();
const { data: users } = useUsers({ page: 1, pageSize: 10 });

// Local UI state
const [isOpen, setIsOpen] = useState(false);
```

## Data Fetching with TanStack Query

### Hook Structure

API hooks are organized by domain under `src/hooks/api/`. Each domain has its own folder with keys, queries, and mutations:

```
src/hooks/api/
├── users/
│   ├── users-keys.ts      # Query key factory (userQueryKeys)
│   ├── users-queries.ts   # Query hooks & fetch functions
│   └── users-mutation.ts  # Mutation hooks
└── files/
    ├── files-keys.ts
    ├── files-queries.ts
    └── files-mutation.ts
```

- **`[domain]-keys.ts`** – Query key factory for that domain (e.g. `userQueryKeys`, `fileQueryKeys`).
- **`[domain]-queries.ts`** – Query hooks and exported fetch functions for prefetch/custom usage.
- **`[domain]-mutation.ts`** – Mutation hooks with cache invalidation.

### Using Query and Mutation Hooks

Import from the domain path; there is no central hooks barrel:

```tsx
import { useCurrentUser, useUsers } from '@/hooks/api/users/users-queries';
import { useUpdateCurrentUser } from '@/hooks/api/users/users-mutation';

function Profile() {
  // Queries - data is cached and shared across components
  const { data: user, isLoading, error } = useCurrentUser();
  const { data: usersData } = useUsers({ page: 1, pageSize: 10 });

  // Mutations - with automatic cache invalidation
  const updateUser = useUpdateCurrentUser({
    onSuccess: () => toast({ title: 'Profile updated!' }),
    onError: (error) => toast({ title: error.message, variant: 'destructive' }),
  });

  const handleSubmit = (data: UpdateUserInput) => {
    updateUser.mutate(data);
  };
}
```

### Query Keys (per domain)

Each domain exposes its own key factory. Use it for cache operations and prefetch:

```tsx
import { userQueryKeys } from '@/hooks/api/users/users-keys';
import { fetchCurrentUser } from '@/hooks/api/users/users-queries';

// For manual cache operations
const queryClient = useQueryClient();

// Invalidate list queries
queryClient.invalidateQueries({ queryKey: userQueryKeys.users() });

// Invalidate specific user
queryClient.invalidateQueries({ queryKey: userQueryKeys.user(userId) });

// Read from cache
const cachedUser = queryClient.getQueryData(userQueryKeys.me());

// Prefetch using exported fetch function
queryClient.prefetchQuery({
  queryKey: userQueryKeys.me(),
  queryFn: fetchCurrentUser,
});
```

### Adding a New API Domain

1. Create `src/hooks/api/[domain]/[domain]-keys.ts`:

```tsx
import type { PaginationParams } from '@repo/shared';

const BASE_KEY = 'posts';

export const postQueryKeys = {
  posts: (params?: PaginationParams) => [BASE_KEY, params] as const,
  post: (id: string) => [BASE_KEY, id] as const,
} as const;

export type PostQueryKeys = typeof postQueryKeys;
```

2. Create `src/hooks/api/[domain]/[domain]-queries.ts` (export fetch functions and query hooks):

```tsx
import { useQuery, type UseQueryOptions } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';
import { postQueryKeys } from './posts-keys';
import type { Post, PaginatedResponse, PaginationParams, ApiError } from '@repo/shared';

export const fetchPosts = async (params?: PaginationParams): Promise<PaginatedResponse<Post>> => {
  const searchParams = new URLSearchParams();
  if (params?.page) searchParams.set('page', String(params.page));
  if (params?.pageSize) searchParams.set('pageSize', String(params.pageSize));
  const query = searchParams.toString();
  const result = await apiClient.get<PaginatedResponse<Post>>(`/posts${query ? `?${query}` : ''}`);
  if (!result.success) throw result.error;
  return result.data!;
};

export function usePosts(
  params?: PaginationParams,
  options?: Omit<UseQueryOptions<PaginatedResponse<Post>, ApiError>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: postQueryKeys.posts(params),
    queryFn: () => fetchPosts(params),
    ...options,
  });
}

export const fetchPost = async (id: string): Promise<Post> => {
  const result = await apiClient.get<Post>(`/posts/${id}`);
  if (!result.success) throw result.error;
  return result.data!;
};

export function usePost(
  id: string,
  options?: Omit<UseQueryOptions<Post, ApiError>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: postQueryKeys.post(id),
    queryFn: () => fetchPost(id),
    enabled: !!id,
    ...options,
  });
}
```

3. Create `src/hooks/api/[domain]/[domain]-mutation.ts` for mutations and invalidate using that domain’s keys:

```tsx
import { useMutation, useQueryClient, type UseMutationOptions } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';
import { postQueryKeys } from './posts-keys';
import type { Post, ApiError } from '@repo/shared';

export function useCreatePost(
  options?: Omit<UseMutationOptions<Post, ApiError, CreatePostInput>, 'mutationFn'>
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreatePostInput) => {
      const result = await apiClient.post<Post>('/posts', data);
      if (!result.success) throw result.error;
      return result.data!;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: postQueryKeys.posts() });
    },
    ...options,
  });
}
```

### Handling Mutation Errors

```tsx
const updateUser = useUpdateCurrentUser({
  onError: (error) => {
    // error is typed as ApiError { code, message, details? }
    toast({
      variant: 'destructive',
      title: error.code,
      description: error.message,
    });
  },
});

// Or with try/catch using mutateAsync
const handleSubmit = async (data: UpdateUserInput) => {
  try {
    await updateUser.mutateAsync(data);
  } catch (error) {
    // error is ApiError
    console.error(error.code, error.message);
  }
};
```

### Cache Behavior

- **staleTime: 5 minutes** - Data is fresh for 5 minutes, no refetch
- **Multiple components, same hook** - Share cached data, single request
- **Automatic deduplication** - Concurrent requests are deduplicated
- **Background refetch** - Stale data triggers background refetch

```tsx
// Component A
const { data } = useCurrentUser(); // API call

// Component B (same time or within 5 min)
const { data } = useCurrentUser(); // Uses cache, no API call
```

## Form Handling

- Use `react-hook-form` with Zod validation
- Import validators from `@repo/shared/validators`
- Use `@hookform/resolvers/zod` for integration

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { signUpSchema, type SignUpInput } from '@repo/shared/validators';

const form = useForm<SignUpInput>({
  resolver: zodResolver(signUpSchema),
});
```

## Routing

- Use TanStack Router with file-based routing
- Routes are defined in `src/routes/` directory
- Pathless layouts use parentheses: `(app)`, `(auth)` - these don't add to the URL path
- Root route at `__root.tsx` defines router context
- Layout routes use `route.tsx` files within pathless groups
- Navigation uses `Link` and `useNavigate` from `@tanstack/react-router`
- Route tree is auto-generated to `routeTree.gen.ts` by the Vite plugin

**File-based Route Structure:**
```
routes/
├── __root.tsx          # Root route with context
├── index.tsx           # Home page (/)
├── (app)/              # Pathless layout group
│   ├── route.tsx       # Layout component
│   └── dashboard.tsx   # /dashboard route
└── (auth)/             # Pathless layout group
    ├── route.tsx       # Auth layout
    └── sign-in.tsx     # /sign-in route
```

**Basic Route:**
```tsx
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/')({
  component: HomePage,
});

function HomePage() {
  return <div>Welcome Home!</div>;
}
```

**Layout Route:**
```tsx
import { createFileRoute, Outlet } from '@tanstack/react-router';

export const Route = createFileRoute('/(app)')({
  component: LayoutComponent,
});

function LayoutComponent() {
  return (
    <div>
      <header>Navigation</header>
      <Outlet /> {/* Child routes render here */}
    </div>
  );
}
```

**Navigation:**
```tsx
import { Link, useNavigate } from '@tanstack/react-router';

// Using Link component
<Link to="/dashboard">Go to Dashboard</Link>
<Link to="/sign-in" className="underline">Sign In</Link>

// Programmatic navigation
const navigate = useNavigate();
navigate({ to: '/dashboard', replace: true });
```

## UI Components from @repo/ui

All Shadcn UI components are located in the `@repo/ui` package and use individual file imports:

```tsx
// Import UI components (individual imports)
import { Button } from '@repo/ui/components/button';
import { Card, CardContent, CardHeader } from '@repo/ui/components/card';
import { Input } from '@repo/ui/components/input';
import { Label } from '@repo/ui/components/label';

// Import utilities
import { cn } from '@repo/ui/lib/utils';

// Import hooks
import { useToast } from '@repo/ui/hooks/use-toast';
```

**Component Location:**
- UI components: `packages/ui/src/components/`
- Utilities: `packages/ui/src/lib/utils.ts` (includes `cn()`)
- Hooks: `packages/ui/src/hooks/use-toast.ts`
- Styles: `packages/ui/src/styles.css` (imported in `apps/web/src/index.css`)

**Adding New Shadcn Components:**

Use the convenient pnpm command from the root of the monorepo:

```bash
# Add a single component
pnpm shadcn add [component-name]

# Add multiple components
pnpm shadcn add dialog select sheet

# Examples
pnpm shadcn add dialog
pnpm shadcn add select sheet accordion
```

The component will be automatically added to `packages/ui/src/components/` and will be immediately available via `@repo/ui/components/[component-name]`. No need to update `package.json` - wildcard exports handle it automatically.

The `components.json` file in `packages/ui` is already configured for shadcn CLI usage.

## Styling with Tailwind

- Use Tailwind utility classes
- Use Shadcn UI components from `@repo/ui/components/*`
- Use the `cn()` utility from `@repo/ui/lib/utils` for conditional classes
- CSS variables and Tailwind theme are shared via `@repo/ui/styles.css`

```tsx
import { cn } from '@repo/ui/lib/utils';

<div className={cn(
  'rounded-lg border bg-card',
  isActive && 'border-primary',
  className
)} />
```

## TypeScript Patterns

- Define prop types with interfaces
- Use `type` for unions and intersections
- Import shared types from `@repo/shared`
- Avoid `any`, use `unknown` when necessary

```tsx
interface UserCardProps {
  user: User;
  onSelect?: (user: User) => void;
  className?: string;
}
```

## Performance

- Memoize expensive computations with `useMemo`
- Memoize callbacks with `useCallback` when passed to optimized children
- Use React.lazy for code splitting
- Avoid premature optimization

## Error Handling

- Use error boundaries for component errors
- Handle async errors with try/catch
- Display user-friendly error messages
- Use the toast system for notifications

```tsx
import { useToast } from '@repo/ui/hooks/use-toast';

const { toast } = useToast();

try {
  await mutateAsync(data);
  toast({ title: 'Success', description: 'Changes saved' });
} catch (error) {
  toast({ title: 'Error', description: 'Failed to save', variant: 'destructive' });
}
```

## Authentication

- Use `useSession()` from `@repo/auth/client` for component-level auth state
- Protect routes using `beforeLoad` in route definitions
- Router context is defined in `__root.tsx` and available in all routes
- Use `redirect()` from TanStack Router for auth redirects

**Router Context Setup (__root.tsx):**
```tsx
import { createRootRoute, Outlet } from '@tanstack/react-router';
import { authClient } from '@/lib/auth';

export const Route = createRootRoute({
  context: () => ({
    auth: authClient,
  }),
  component: RootComponent,
});
```

**Protected Route with beforeLoad:**
```tsx
import { createFileRoute, redirect } from '@tanstack/react-router';
import { authClient } from '@/lib/auth';

export const Route = createFileRoute('/(app)/dashboard')({
  beforeLoad: async ({ context }: { context: { auth: typeof authClient } }) => {
    // Check authentication
    const result = await context.auth.getSession();
    if (result.error || !result.data?.user) {
      throw redirect({
        to: '/sign-in',
        search: {
          redirect: '/dashboard',
        },
      });
    }
  },
  component: DashboardPage,
});
```

**Using Session in Components:**
```tsx
import { useSession, signIn, signOut } from '@/lib/auth';

function MyComponent() {
  const { data: session, isPending } = useSession();

  if (isPending) return <LoadingSpinner />;
  if (!session?.user) {
    // Handle unauthenticated state
    return <div>Please sign in</div>;
  }

  return <div>Welcome, {session.user.name}!</div>;
}
```
